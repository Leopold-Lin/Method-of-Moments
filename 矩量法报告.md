# 					<center>矩量法报告</center>

## 第一章 确定论问题

- 第一章中所有方法都是解决同一个算子方程

- $$
  -\frac {d^2f}{dx^2} = 1 + 4x^2
  $$

- 边界条件为

- $$
  f(0) = f(1) = 0
  $$

- 其精确解为

- $$
  f(x) = \frac 56x - \frac 12x^2 - \frac 13x^4
  $$







### 伽略金

#### 计算理论

> 选择基函数
> $$
> f_n = x - x^{n+1}
> $$
> 式中$$n = 1 , 2 , 3 , ... , N$$
>
> 结果为
> $$
> f = \sum^N_{n = 1} \alpha_n(x - x^{n+1})
> $$
> 在伽略金法中使检验函数与基函数相同
> $$
> w_n = f_n = x - x^{n+1}
> $$
> 构造方程
> $$
> \sum_n\alpha_n<w_m,Lf_n> = <w_m,g>
> $$
> 式中$$m = 1 , 2 , 3 , ... $$，其中$$<f,g>$$表示函数 $$f$$ 与 $$g$$ 的内积，并不是固定的，在这里我们定义为$$\int f \cdot g\ dx$$，在这里算子 $$L$$ 为 $$-\frac {d^2f}{dx^2}$$ ，$$g$$ 为 $$1 + 4x^2$$ 。
>
> 写成矩阵形式
> $$
> [l_{mn}] [\alpha_n] = [g_m]
> $$
> 其中
> $$
> [l_{mn}] = \left[\begin{matrix}
> 		<w_1,Lf_1> & <w_1,Lf_1> & ... \\
> 		<w_1,Lf_1> & <w_1,Lf_1> & ... \\
> 		... & ... & ...
> 		\end{matrix} \right]
> $$
>
> $$
> [\alpha_n] = \left[ \begin{matrix}
> 		\alpha_1 \\
> 		\alpha_2 \\
> 		:
> 	    	\end{matrix} \right]
> 	    	\qquad
> 	    	[g_m] = \left[ \begin{matrix}
> 		<w_1,g>\\
> 		<w_2,g> \\
> 		:
> 	    	\end{matrix} \right]
> $$
>
> 通过对$$[l_{mn}]$$矩阵求逆矩阵，可算出基函数的系数$$[\alpha_n] = [l_{mn}^{-1}][g_m]$$，从而得到算子方程的近似解。

#### 计算程序

```matlab
clear;clc;
n = input('Input the N \n')
%Galerkin Method
syms x
g = 1 + 4*x^2;
fa = 5/6*x -1/2*x^2 -1/3*x^4;    %实际解
for i = 1:n
    fn(i) = x - x^(i+1);
    wn(i) = fn(i);              %伽略金法检验函数等于基函数
    lfn(i) = -diff(diff(fn(i)));
end
for i = 1:n
    for j = 1:n
        lmn(i,j) = int(wn(i)*lfn(j),x,0,1); %求内积
    end
    gm(i) = int(wn(i)*g,x,0,1);
end
a = lmn\gm';
f = fn*a;   %因为矩阵形状所以相应矩阵乘法调换顺序
val = 0:0.01:1;
plot(val,subs(f,val),'p')
hold on
plot(val,subs(fa,val),'r')
str=['N = ',num2str(n)];
title(str);
legend('矩量法解','精确值');
```

#### 计算结果

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\伽略金法N=1.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\伽略金法N=2.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\伽略金法N=3.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\伽略金法N=4.png)

#### 总结

​	可以看到随着展开函数数目的增加，矩量法解在逐步逼近精确解，因为该算子方程的特例性，在$$N = 4$$的时候矩量法解完全等于精确解。

​	在编写程序的时候因为此问题较为简单，并没有使用矩阵元素 $$l_{mn}$$ 的解析式，而是直接使用MATLAB计算内积。

### 点选配

#### 计算理论

> ​	在实际情况中，要计算内积 $$l_{mn} = <w_1,Lf_1>$$ 中的积分通常是很困难的，所以求近似解的一个简单方法是在所关心的区域内要求在一些离散点上满足算子方程，这种方法叫做点选配。
>
> ​	简而言是就是相当于使用狄拉克(Dirac) $$\delta$$ 函数作为检验函数
>
> ​	使用点选配方法计算本章的算子方程，仍选择 $$f_n = x - x^{n+1}$$ 为基函数，等价于计算
> $$
> \sum^N_{n=1} \alpha_n\left[ -\frac {d^2}{dx^2}(x-x^{n+1}) \right] = 1 + 4x^2
> $$
> 选择下面的点
> $$
> x_m = \frac m{N+1}
> \qquad
> m = 1,2,3,...,N
> $$
> 在区间 $$0 \le x \le 1$$ 中，它是等间隔的，要求每个 $$\alpha_n$$ 都满足上式。可得到矩阵元素
> $$
> l_{mn} = n(n+1)\left( \frac m{N+1} \right)^{n-1} 
> $$
>
> $$
> g_m = 1 + 4\left( \frac m{N+1} \right)^2
> $$
>

#### 计算程序

```matlab
clear;clc
n = input('Input the N...\n')
%Point matching
syms x;
g = 1 + 4*x^2;
fa = 5/6*x -1/2*x^2 -1/3*x^4;   %实际解
for i = 1:n
    fn(i) = x - x^(i+1);
end
for i = 1:n
    for j = 1:n
        lmn(i,j) = -diff(diff(fn(j)));
        lmn(i,j) = subs(lmn(i,j),x,i*(1/(n+1)));    %点选配方法
    end
    gm(i) = subs(g,x,i*(1/(n+1)));
end
a = lmn\gm';
f = fn*a;
val = 0:0.01:1;
plot(val,subs(f,val),'p')
hold on
plot(val,subs(fa,val),'r')
str=['N = ',num2str(n)];
title(str);
legend('矩量法解','精确值');
```

#### 计算结果

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\点选配N=1.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\点选配N=2.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\点选配N=3.png)

#### 总结

​	点选配相对于伽略金法计算简便，易于理解。同样因为本章例子的特殊性，在 $$N=3$$ 的时候矩量法解等于精确解。

### 分域基

#### 计算理论

> ​	分域基法采用各个基函数只是在 $$f$$ 定义域的各个分域上才存在，于是，解的展开式的每个 $$\alpha_n$$ 只是在我们所关心的区域的各个分域上才影响 $$f$$ 的近似。
>
> ​	在这里我们定义两个函数：脉冲函数与三角形函数，来解决本章例题。
>
> - 脉冲函数
>
>
> - $$
>   \begin{equation}
>   P(x) =
>   \begin{cases} 
>   1 & \vert x\vert<\frac 1{2(N+1)} \\
>   0 & |x|>\frac 1{2(N+1)}
>   \end{cases}
>   \end{equation}
>   $$
>
>
>
> 
>
> - 三角形函数
>
> - $$
>   \begin{equation}
>   T(x) =
>   \begin{cases} 
>   1- | x | (N+1) & |x|<\frac 1{N+1} \\
>   0 & |x|>\frac 1{N+1}
>   \end{cases}
>   \end{equation}
>   $$
>
>   因为脉冲函数不能取二阶导数，所以我们取三角形函数作为基函数，$$f$$ 的分段线性近似为
>   $$
>   f = \sum^N_{n=1} \alpha_nT(x-x_n)
>   $$
>
>
>
>
> 对于$$L= -\frac {d^2f}{dx^2}$$ ，进行 $$LT$$ 运算：
> $$
> LT(x-x_n) = (N+1)[-\delta(x-x_{n-1}) +2\delta(x-x_n)-\delta(x-x_{n+1})]
> $$
> 令基函数 $$f_n=T(x-x_n)$$ ，选择 $$w_m = P(x-x_m)$$ 为检验函数，便可算出矩阵元素
> $$
> \begin{equation}
> l_{mn} = 
> \begin{cases}
> 2(N+1) & m=n \\
> -(N+1) & |m-n| = 1 \\
> 0	& |m-n| > 1
> \end{cases}
> \end{equation}
> $$
>
> $$
> g_m = \frac 1{N+1} \left[ 1+ \frac {4m^2+ \frac 13}{(N+1)^2} \right]
> $$
>

#### 计算程序

```matlab
clear;clc;
n = input('Input the N...\n')
%subsectional bases
syms x;
g = 1 + 4*x^2;
fa = 5/6*x -1/2*x^2 -1/3*x^4;   %实际解
for i = 1:n
    %基函数为三角形函数，检验函数为脉冲函数
    xm = i * 1/(n+1);
    %两种定义基函数的方法同样有用，在这里选择内置piecewise函数
    %fn(i) = (1-abs(x-xm)*(n+1)) .* ( x - xm < (1/(n+1)) &  x - xm > -(1/(n+1)));
    fn(i) = piecewise(abs(x - xm) < 1/(n+1) ,1-abs(x-xm)*(n+1),0);
end
lmn = ones(n,n);
gm = ones(n,1);
for i = 1:n
    for j = 1:n
        if i == j
            lmn(i,j) = 2*(n+1);
        elseif i - j == 1 | j - i == 1
            lmn(i,j) = - (n+1);
        else
            lmn(i,j) = 0;
        end
    end
    gm(i) = 1/(n+1) * (1+(4*i^2+1/3)/(n+1)^2);
end
a = lmn\gm;
val = 0:0.01:1;
f = fn * a;
plot(val,eval(subs(f,x,val)));
hold
plot(val,subs(fa,x,val));
str=['N = ',num2str(n)];
title(str);
legend('矩量法解','精确值');
```

#### 计算结果

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\分域基法N=1.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\分域基法N=2.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\分域基法N=3.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\分域基法N=9.png)

#### 总结

​	可以看到，一开始因为对定义域的分解非常粗糙，所以矩量法解与精确解之间的误差是非常大的，但是随着对定义域分解精细度逐步提高，矩量法解也随之越来越接近于精确解。

​	在一开始的时候我想单纯的使用`piecewise`函数构造基函数（三角函数）与检验函数（脉冲函数），然后使用MATLAB自带的微分函数来进行处理得到 $$l_{mn}$$ ，但是经过 $$L$$ 算子处理，
$$
预期结果 \qquad LT(x-x_n) = (N+1)[-\delta(x-x_{n-1}) +2\delta(x-x_n)-\delta(x-x_{n+1})]
$$

$$
实际结果 \qquad LT(x-x_n) = (N+1)\ 2\delta(x-x_n)
$$

丢失了两边的两个 $$\delta$$ 函数，只有中间系数为2的 $$\delta$$ 函数，然后我尝试了使用布尔值来构造基函数，但是使用MATLAB自带的微分函数还是不能得到两边的 $$\delta$$ 函数，因此只能直接使用
$$
\begin{equation}
l_{mn} = 
\begin{cases}
2(N+1) & m=n \\
-(N+1) & |m-n| = 1 \\
0	& |m-n| > 1
\end{cases}
\end{equation}
$$
来对其进行计算。

​	在构造基函数的过程中，使用布尔值来构造分段函数`fn(i) = (1-abs(x-xm)*(n+1)) .* ( x - xm < (1/(n+1)) &  x - xm > -(1/(n+1)))`与使用MATLAB内置`piecewise`函数来构造经测试效果是相同的。



## 第二章 静电场

### 带电导体板

#### 计算理论

> ​	本节例子为单位边长正方形导体板，位于 $$z=0$$ 的平面上，$$\sigma(x,y)$$ 表示导体板上的面电荷密度，板的厚度为零。空间中任意一点的静电位是
> $$
> \phi (x,y,z) = \int^a_{-a}\,dx'\int^a_{-a}\,dy'\, \frac {\sigma(x',y')}{4\pi\epsilon R}
> $$
> 其中 $$R = \sqrt{(x-x')^2+(y-y')^2+z^2}$$ 。板上的边界条件是 $$\phi = V $$ （常数），此时的积分方程是
> $$
> V =  \int^a_{-a}\,dx'\int^a_{-a}\,dy'\, \frac {\sigma(x',y')}{4\pi\epsilon { \sqrt{(x-x')^2+(y-y')^2}}}
> $$
> 式中 $$|x|<a$$，$$|y|<a$$ ，待求的未知函数是电荷密度 $$\sigma(x,y)$$ 。一个有意义的参数是导体板的电容：
> $$
> C = \frac qV = \frac 1V \int^a_{-a}\,dx\int^a_{-a}\,dy\, {\sigma(x,y)}
> $$
> 求解的过程为，将导体板划分为 $$N$$ 个正方形小块，定义基函数
> $$
> \begin{equation}
> f_n = 
> \begin{cases}
> 1 & 在\triangle S_n上 \\
> 0 & 在所有其它\triangle S_m上
> \end{cases}
> \end{equation}
> $$
> 电荷密度表示为
> $$
> \sigma(x,y) \approx \sum^N_{n=1}\alpha_nf_n
> $$
> 在每个 $$\triangle S_m$$ 中点满足 $$(x_m,y_m)$$ 满足所得方程
> $$
> V = \sum^N_{n=1}l_{mn}\alpha_n \qquad m=1,2,...,N
> $$
>
> $$
> l_{mn} =  \int^a_{-a}\,dx'\int^a_{-a}\,dy'\, \frac 1{4\pi\epsilon { \sqrt{(x_m-x')^2+(y_m-y')^2}}}
> $$
>
> $$l_{mn}$$ 是 $$\triangle S_n$$ 上单位振幅的均匀电荷密度在 $$\triangle S_m$$ 的中心处产生的电位。
> $$
> C = \frac {<\sigma,\phi>}{V^2}
> $$
>

#### 计算程序

```matlab
clear;clc
n = input('Input the number of square:N \n')
%平板为单位面积平板
num = n^0.5;
v = 1;
a = 1 / 2;
b = a / num;
epsilon = 8.854187817e-12;   %真空中的介电常数
if mod(num,1) ~= 0
    error('the N is a wrong number ! It must be a square number')
end
syms x y;         
%lmn是delta_Sn上单位振幅的均匀电荷密度在delta_Sm的中心处产生的电位
for i = 1:n
    for j = 1:n
        if i == j   % m=n的情况
            lmn(i,j) = 2*b/(pi*epsilon) *0.8814;
        else        % m~=n的情况
            if mod(i,num) == 0
                xm = fix(i/num);
                ym = num;
            else
                xm = fix(i/num) +1;
                ym = mod(i,num);
            end
            if mod(j,num) == 0
                xn = j/num;
                yn = num;
            else
                xn = fix(j/num) + 1;
                yn = mod(j,num);
            end
            deltax = 2*b*(xm-xn);   %Xm与Xn之间的距离
            deltay = 2*b*(ym-yn);   %Ym与Yn之间的距离
            %disp(['i=',num2str(i),'j=',num2str(j),' ',num2str([xm,ym,xn,yn])])
            %验证编号问题，成功
            test(i,1) = xm;test(i,2) = ym;test(i,3) = xn;test(i,4) = yn;
            lmn(i,j) = b^2 / (pi*epsilon* (deltax^2 + deltay^2)^0.5 );
        end
    end
    gm(i) = v;
end
a = lmn\gm';    %好像只要求出alpha，然后将其reshape就行了
a_reshape = reshape(a,num,num);
c = 4*b*b*sum(a);   %电容
surf(a_reshape);
```

#### 计算结果

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\单导体板1024分块.png)

![Alt text](C:\Users\Zhou\Documents\Method-of-Moments\单导体板4096分块.png)

#### 总结

​	在计算这个例子的过程中的主要问题就是通过 1~n 的编号来计算 $$\triangle S_n$$ 与 $$\triangle S_m$$ 之间的距离，在这里使用了标号与行列数之间的余数与商来求得两块面积中点之间的距离，比较繁琐。

### 平行带电导体板

#### 计算理论

> 计算两块单位面积平行防止的导体板，两块导体板各自的情况与单导体板相同，
>
> 

#### 计算程序

#### 计算结果

#### 总结



## 第三章 二维电磁场

### 导电柱体 TM情况

### 导电柱体 TE情况

## 第四章 线天线及散射体

### 线天线

### 线状散射体

> 本报告使用Markdown完成，程序使用MATLAB执行，版本为2016b